**************************************main.cpp*********************************
//ЗАДАНИЕ 1
//Создать класс Overcoat (верхняя одежда).
//Реализовать перегруженные операторы:
//1. Проверка на равенство типов одежды (операция == ).
//2. Операцию присваивания одного объекта в другой (операция = ).
//3. Сравнение по цене двух пальто одного типа (операция > ).
//
//ЗАДАНИЕ 2
//Создать класс Flat (квартира).
//Реализовать перегруженные операторы:
//1. Проверка на равенство площадей квартир (операция == ).
//2. Операцию присваивания одного объекта в другой (операция = ).
//3. Сравнение двух квартир по цене (операция > ).

#include <iostream>
#include "overcoat.h"
#include "flat.h"

using namespace std;

int main()
{
    int counter = 1;

    cout << "OVERCOAT:" << endl;
    
    Overcoat over1{ "palto1", Overcoat::coat, 99.99};
    cout << counter++ << ". ";
    over1.display();

    Overcoat over2{ "palto2", Overcoat::coat, 199.99 };
    cout << counter++ << ". ";
    over2.display();

    Overcoat over3{ "palto3", Overcoat::coat, 99.99 };
    cout << counter++ << ". ";
    over3.display();

    Overcoat over4{ "kurtka1", Overcoat::jaket, 59.99 };
    cout << counter++ << ". ";
    over4.display();

    Overcoat over5{ "plasch1", Overcoat::raincoat, 99.99 };
    cout << counter++ << ". ";
    over5.display();

    Overcoat over6{ "shapka1", Overcoat::cap, 19.99 };
    cout << counter++ << ". ";
    over6.display();

    Overcoat over7{ "shapka0", Overcoat::cap, 10.99 };
    cout << counter << ". ";
    over7.display();

    cout << "Compare 1 and 2 from type (1 - true, 0 - false): " << (over1 == over2) << endl;
    cout << "Compare 1 and 4 from type (1 - true, 0 - false): " << (over1 == over4) << endl;
    
    cout << "Assignment 4 to 7: " << counter << ". ";
    over7 = over4;
    over7.display();

    cout << "Compare 2 and 3 from price (0 - equal, 1 - 1 more 2, 2 - 2 more 1): " << (over2 > over3) << endl;
    cout << "Compare 6 and 5 from price (0 - equal, 1 - 1 more 2, 2 - 2 more 1): " << (over6 > over5) << endl;
    cout << "Compare 3 and 5 from price (0 - equal, 1 - 1 more 2, 2 - 2 more 1): " << (over3 > over5) << endl;

    counter = 1;
    
    cout << "\nFLATS:" << endl;

    Flat flat1{ 1, 1, 1, 65, 2500000 };
    cout << counter++ << ". ";
    flat1.display();
    Flat flat2{ 2, 1, 2, 70, 3000000 };
    cout << counter++ << ". ";
    flat2.display();
    Flat flat3{ 3, 1, 3, 90, 5000000 };
    cout << counter++ << ". ";
    flat3.display();
    Flat flat4{ 4, 2, 1, 65, 2500000 };
    cout << counter++ << ". ";
    flat4.display();
    Flat flat5{ 5, 2, 2, 70, 3000000 };
    cout << counter++ << ". ";
    flat5.display();
    Flat flat6{ 6, 2, 3, 70, 5000000 };
    cout << counter << ". ";
    flat6.display();

    cout << "Compare 1 and 4 from square (1 - true, 0 - false): " << (flat1 == flat4) << endl;
    cout << "Compare 2 and 3 from square (1 - true, 0 - false): " << (flat2 == flat3) << endl;

    cout << "Assignment 1 to 6: " << counter << ". ";
    flat6 = flat1;
    flat6.display();

    cout << "Compare 1 and 4 from price (0 - equal, 1 - 1 more 2, 2 - 2 more 1): " << (flat1 > flat4) << endl;
    cout << "Compare 3 and 2 from price (0 - equal, 1 - 1 more 2, 2 - 2 more 1): " << (flat3 > flat2) << endl;
    cout << "Compare 4 and 5 from price (0 - equal, 1 - 1 more 2, 2 - 2 more 1): " << (flat4 > flat5) << endl;

    return 0;
}
*****************************************overcoat.h******************************
#pragma once
#include <iostream>
using namespace std;

class Overcoat
{
public:
	
	enum typeOvercoat { jaket, raincoat, coat, cap };

private:
	
	char* name;
	typeOvercoat typeOfOvercoat;
	double price;
	
public:

	Overcoat();

	Overcoat(const char* newName, const typeOvercoat typeOfOvercoat, const double newPrice);

	void setName(const char* newName);
	const char* enumToString(typeOvercoat typeOfOvercoat);
	void setPrice(const double newPrice);
	void setCharArray(char*& destenation, const char* source);
	void clearClass();
	void display();

	Overcoat& operator= (const Overcoat& over);
	
	friend bool operator==(const Overcoat& over1, const Overcoat& over2);

	friend int operator>(const Overcoat& over1, const Overcoat& over2);

};
****************************************overcoat.cpp*********************************
#include "overcoat.h"

Overcoat::Overcoat() : Overcoat{ nullptr, coat, 0 }
{

}

Overcoat::Overcoat(const char* newName, const typeOvercoat newTypeOfOvercoat, const double newPrice)
    : name{ newName ? new char[strlen(newName) + 1] : nullptr },
    typeOfOvercoat{ newTypeOfOvercoat }, price{ newPrice }
{
    if (name)
    {
        strcpy_s(name, strlen(newName) + 1, newName);
    }
}

void Overcoat::setName(const char* newName)
{
	this->name = new char[strlen(newName) + 1];
	strcpy_s(name, strlen(newName) + 1, newName);
}

const char* Overcoat::enumToString(typeOvercoat typeOfOvercoat)
{
    switch (typeOfOvercoat)
    {
    case jaket:     return "jaket";
    case raincoat:  return "raincoat";
    case coat:      return "coat";
    case cap:       return "cap";
    default:        return nullptr;
    }
}

void Overcoat::setPrice(const double newPrice)
{
	this->price = newPrice;
}

void Overcoat::setCharArray(char*& destenation, const char* source)
{
    int strSize = strlen(source) + 1;
    destenation = new char[strSize];
    strcpy_s(destenation, strSize, source);
}

void Overcoat::clearClass()
{
    if (this->name != nullptr)
    {
        delete[] name;
    }
}

void Overcoat::display()
{
    cout << "Name: " << this->name << ", type of overcoat: " << enumToString(this->typeOfOvercoat) << ", price: " << this->price << endl;
}

Overcoat& Overcoat::operator=(const Overcoat& over)
{
    // обходим самокопирование
    if (this == &over)
    {
        return *this;
    }

    // если уже есть значение, то удаляем это значение
    clearClass();

    // выполняем глубокое копирование
    setCharArray(this->name, over.name);
    
    this->typeOfOvercoat = over.typeOfOvercoat;
    this->price = over.price;

    // Возвращаем текущий объект
    return *this;
}

bool operator==(const Overcoat& over1, const Overcoat& over2)
{
    return over1.typeOfOvercoat == over2.typeOfOvercoat;
}

int operator>(const Overcoat& over1, const Overcoat& over2)
{
    if (over1.price > over2.price)
    {
        return 1;
    }
    else if (over1.price < over2.price)
    {
        return 2;
    }
    else
    {
        return 0;
    }
}
****************************************flat.h********************************
#pragma once
#include <iostream>
using namespace std;

class Flat
{
private:

	int flatNumber;
	int floor;
	int countOfRooms;
	double squareOfFlat;
	double priceOfFlat;

public:

	Flat();

	Flat(const int newFlatNumber, const int newFloor, const int newCountOfRooms, const double newSquareOfFlat, const double newPriceOfFlat);

	void display();

	Flat& operator= (const Flat& flat);

	friend bool operator==(const Flat& flat1, const Flat& flat2);

	friend int operator>(const Flat& flat1, const Flat& flat2);

};
***************************************flat.cpp************************************
#include "flat.h"

Flat::Flat() : Flat{0,0,0,0,0}
{

}

Flat::Flat(const int newFlatNumber, const int newFloor, const int newCountOfRooms, const double newSquareOfFlat, const double newPriceOfFlat)
	: flatNumber{ newFlatNumber }, floor{ newFloor }, countOfRooms{ newCountOfRooms }, squareOfFlat { newSquareOfFlat }, priceOfFlat{ newPriceOfFlat }
{

}

void Flat::display()
{
	cout << "Flat number: " << this->flatNumber << ", floor: " << this->floor << ", count of rooms: " << this->countOfRooms << ", square: " << this->squareOfFlat << ", price: " << this->priceOfFlat << endl;
}

Flat& Flat::operator=(const Flat& flat)
{
    // обходим самокопирование
    if (this == &flat)
    {
        return *this;
    }

    this->flatNumber = flat.flatNumber;
    this->floor = flat.floor;
    this->countOfRooms = flat.countOfRooms;
    this->squareOfFlat = flat.squareOfFlat;
    this->priceOfFlat = flat.priceOfFlat;

    // Возвращаем текущий объект
    return *this;
}

bool operator==(const Flat& flat1, const Flat& flat2)
{
    return flat1.squareOfFlat == flat2.squareOfFlat;
}

int operator>(const Flat& flat1, const Flat& flat2)
{
    if (flat1.priceOfFlat > flat2.priceOfFlat)
    {
        return 1;
    }
    else if (flat1.priceOfFlat < flat2.priceOfFlat)
    {
        return 2;
    }
    else
    {
        return 0;
    }
}