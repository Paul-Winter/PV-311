********************************main.cpp********************************
//ЗАДАНИЕ 2.
//Используя механизм шаблонного наследования создайте
//иерархию классов. Базовый класс под названием base
//имеет следующие переменные - члены:
//1. T1 value1; // некоторое значение.
//2. T2 value2; // некоторое значение.
//Потомок под названием child содержит дополнительные переменные - члены:
//1. T3 value3.
//2. T4 value4.
//Потомок под названием child2 добавляет такие переменные - члены :
//1. T5 value5.
//2. T6 value6.
//Каждый класс имеет необходимый набор конструкторов,
//деструкторов, функций - членов для работы со структурой класса.
//В main протестировать работу класса.

#include <iostream>
#include "base.h"
#include "child.h"
#include "child2.h"
using namespace std;

int main()
{

	int value1 = 10;
	short value2 = 5;
	double value3 = 10.1;
	float value4 = 5.6;
	char value5 = 'A';
	bool value6 = true;
	
	Base <int, short> bsd(value1, value2);
	Child <int, short, double, float> chld(value3, value4);
	Child2 <int, short, char, bool> chld2(value5, value6);
	
	bsd.display();
	chld.display();
	chld2.display();
		
	return 0;
}
**********************************base.h*************************************
#pragma once
#include <iostream>
using namespace std;

template <class T1, class T2>
class Base
{
protected:

	T1 value1;
	T2 value2;

	Base();
	
public:
	
	Base(T1 value1, T2 value2);
	~Base();

	void display();

};

template<class T1, class T2>
inline Base<T1, T2>::Base()
{

}

template<class T1, class T2>
inline Base<T1, T2>::Base(T1 value1, T2 value2) : value1{ value1 }, value2{ value2 }
{

}

template<class T1, class T2>
inline Base<T1, T2>::~Base()
{

}

template<class T1, class T2>
inline void Base<T1, T2>::display()
{
	cout << "Base: T1=" << value1 << ", T2=" << value2 << endl;
}
********************************child.h***************************************
#pragma once
#include "base.h"

template <class T1, class T2, class T3, class T4>
class Child : public Base <T1, T2>
{
protected:

	T3 value3;
	T4 value4;

	Child();

public:

	Child(T3 value3, T4 value4);
	~Child();

	void display();
};

template<class T1, class T2, class T3, class T4>
inline Child<T1, T2, T3, T4>::Child()
{

}

template<class T1, class T2, class T3, class T4>
inline Child<T1, T2, T3, T4>::Child(T3 value3, T4 value4) : value3{ value3 }, value4{ value4 }
{

}

template<class T1, class T2, class T3, class T4>
inline Child<T1, T2, T3, T4>::~Child()
{

}

template<class T1, class T2, class T3, class T4>
inline void Child<T1, T2, T3, T4>::display()
{
	cout << "Child: T3=" << value3 << ", T4=" << value4 << endl;
}
*************************************child2.h*********************************
#pragma once
#include "base.h"

template <class T1, class T2, class T5, class T6>
class Child2 : public Base <T1, T2>
{
protected:

	T5 value5;
	T6 value6;

	Child2();

public:
	
	Child2(T5 value5, T6 value6);
	~Child2();

	void display();
};

template<class T1, class T2, class T5, class T6>
inline Child2<T1, T2, T5, T6>::Child2()
{

}

template<class T1, class T2, class T5, class T6>
inline Child2<T1, T2, T5, T6>::Child2(T5 value5, T6 value6) : value5{ value5 }, value6{ value6 }
{

}

template<class T1, class T2, class T5, class T6>
inline Child2<T1, T2, T5, T6>::~Child2()
{

}

template<class T1, class T2, class T5, class T6>
inline void Child2<T1, T2, T5, T6>::display()
{
	cout << "Child2: T5=" << value5 << ", T6=" << value6 << endl;
}